using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using FarseerPhysics;
using FarseerPhysics.Dynamics;
using FarseerPhysics.Factories;
using FarseerPhysics.Collision;
using FarseerPhysics.Common;
using UeFGame.GameObjects;
using UeFGame.GameObjects.Player;
using UeFGame.GameComponents;
using System.Reflection;
namespace UeFGame.GameComponents
{
    /// <summary>
    /// Class representing the GameMap.
    /// It contains all the physics and logic of the map.
    /// </summary>
    public class GameMap
    {
        /// <summary>
        /// List of map assemblies loaded indexed by MapId.
        /// </summary>
        public Dictionary<int, System.Reflection.Assembly> Assemblies;

        Vector2 MapDefaultGravity = Vector2.UnitY*40;
        /* --------------------------------------------------------------------------------
        * Variables
        * -------------------------------------------------------------------------------*/
        #region Variables
        /// <summary>
        /// The Object Pool of the map
        /// </summary>
        List<GameObject> m_gameObjects = new List<GameObject>();
        /// <summary>
        /// The physics world of the map
        /// </summary>
        World m_world;
        /// <summary>
        /// Size of the map in simulation units.
        /// </summary>
        Vector2 m_sizeSim;
        /// <summary>
        /// Scrolling of the map in pixels
        /// </summary>
        Vector2 m_scrollPx;
        /// <summary>
        /// Object kept in reference for scrolling.
        /// This object will always be at the center of the screen.
        /// </summary>
        GameObjects.GameObject m_scrollRef;
        /// <summary>
        /// Reference to the player.
        /// </summary>
        Player m_player;
        /// <summary>
        /// Reference to the Game HUD hosting HUD components.
        /// </summary>
        GameHUD m_hud;

        #region Tiles
        /// <summary>
        /// List of the Bodies generated by the tiles.
        /// </summary>
        List<Body> m_TileBodies;
        /// <summary>
        /// The Tileset of this map.
        /// </summary>
        Tileset m_tileset;
        /// <summary>
        /// Ids of the tiles.
        /// </summary>
        int[][,] m_tileIds;
        /// <summary>
        /// Texture of the tileset.
        /// </summary>
        Texture2D m_tilesetTexture;
        #endregion
        #endregion
        /* --------------------------------------------------------------------------------
        * Properties
        * -------------------------------------------------------------------------------*/
        #region Properties
        /// <summary>
        /// Gets the player.
        /// </summary>
        /// <returns></returns>
        public Player GetPlayer()
        {
            return m_player;
        }
        /// <summary>
        /// Gets a reference to the Game HUD.
        /// </summary>
        public GameHUD HUD
        {
            get { return m_hud; }
        }
        #endregion
        /* --------------------------------------------------------------------------------
        * Basics
        * -------------------------------------------------------------------------------*/
        #region Basics
        /// <summary>
        /// Constructor of the game map
        /// </summary>
        public GameMap()
        {
            Assemblies = new Dictionary<int, Assembly>();
            m_world = new World(MapDefaultGravity);
            m_gameObjects = new List<GameObject>();
            m_TileBodies = new List<Body>();
            GameObjects.Particles.ParticlePools.Initialize();
            GameObjects.Shoots.ShootPools.Initialize();
            Globals.World = m_world;
            Globals.GameObjectPool = m_gameObjects;
            Globals.GameMap = this;
            m_hud = new GameHUD();
            // TEST
            for (int i = 0; i < 1; i++)
            {
                DEBUG_genCrate();
            }
            // Scrollref
            

            LoadMap(Globals.Cfg.StartMapId);
            m_scrollRef = m_player;
        }

        void DEBUG_genCrate()
        {
            Random rand = Globals.Rand;
            GameEvent evt = new GameEvent();
            ModuleSet set = new ModuleSet();
            GameObjectInit init = new GameObjectInit();
            set.Base.SimStartX = rand.Next(2000)/100.0f;
            set.Base.SimStartY = 1f;
            set.Base.Name = "LOLILOL";
            PhysicalObjectModule phi = new PhysicalObjectModule();
            phi.BodyType = BodyType.Dynamic;
            phi.ShapeSizeSim = new Vector2(0.64f, 0.64f);
            phi.BodyCategory = BodyCategories.Friend;
            phi.BodyDensity = 5f;
            phi.BodyFriction = 0.100f;
            phi.IsFixedRotation = false;
            phi.ShapeType = ShapeType.Rectangle;
            GameEventModule ev = new GameEventModule();
            set["physical_object"] = phi;
            set["game_event"] = ev;
            ev.TextureName = "RunTimeAssets\\Graphics\\GameObjects\\test";
            init.ModuleSet = set;
            evt.InitializingData = init;
            evt.Initialize();
            evt.Body.LinearVelocity = new Vector2(-5, evt.Body.LinearVelocity.Y);
            m_gameObjects.Add(evt);
        }
        /* --------------------------------------------------------------------------------
        * Update
        * -------------------------------------------------------------------------------*/
        #region Update
        /// <summary>
        /// Updates the game map.
        /// </summary>
        /// <param name="gameTime"></param>
        public void Update(GameTime gameTime)
        {
            m_world.Step((float)gameTime.ElapsedGameTime.TotalSeconds);
            // Updates the GameObjects
            UpdateObjects(gameTime);
            // Updates the scrolling
            UpdateScrolling();
        }

        /// <summary>
        /// Update the game objects
        /// </summary>
        void UpdateObjects(GameTime gameTime)
        {
            for (int i = 0; i < m_gameObjects.Count; i++)
            {
                if (m_gameObjects[i].IsDisposed)
                {
                    m_gameObjects.RemoveAt(i);
                    i--;
                }
                else
                {
                    m_gameObjects[i].Update(gameTime);
                }
            }
            GameObjects.Shoots.ShootPools.Update(gameTime);
            m_player.Update(gameTime);
        }

        public int ScrollSpeed = 5;
        public int ScrollDistanceThreshold = 100;
        /// <summary>
        /// Updates the scrolling
        /// </summary>
        void UpdateScrolling()
        {
            if (m_scrollRef != null)
            {
                /*
                m_scrollPx.X = (int)Math.Max(0, Math.Min(disp(m_scrollRef.SimX) - Globals.ScreenWidth / 2, disp(m_sizeSim.X) - Globals.ScreenWidth));
                m_scrollPx.Y = (int)Math.Max(0, Math.Min(disp(m_scrollRef.SimY) - Globals.ScreenHeight / 2, disp(m_sizeSim.Y) - Globals.ScreenHeight));*/
                Vector2 goal = new Vector2();
                goal.X = (int)Math.Max(0, Math.Min(disp(m_scrollRef.SimX) - Globals.ScreenWidth / 2, disp(m_sizeSim.X) - Globals.ScreenWidth));
                goal.Y = (int)Math.Max(0, Math.Min(disp(m_scrollRef.SimY) - Globals.ScreenHeight / 2, disp(m_sizeSim.Y) - Globals.ScreenHeight));
                
                // Smooth scrolling
                Vector2 dst = goal - m_scrollPx;
                int dstX = (int)Math.Abs(dst.X);
                if (dstX >= ScrollSpeed)
                    m_scrollPx.X += Math.Sign(dst.X) * ScrollSpeed;
                else if (dst.X <= 0.1f)
                    m_scrollPx.X = goal.X;
                else
                    m_scrollPx.X += Math.Sign(dst.X);

                int dstY = (int)Math.Abs(dst.Y);
                if (dstY >= ScrollSpeed)
                    m_scrollPx.Y += Math.Sign(dst.Y) * ScrollSpeed;
                else if (dst.X <= 0.1f)
                    m_scrollPx.Y = goal.Y;
                else
                    m_scrollPx.Y += Math.Sign(dst.Y);

                m_scrollPx.X = (int)Math.Max(goal.X - ScrollDistanceThreshold, Math.Min(m_scrollPx.X, goal.X + ScrollDistanceThreshold));
                m_scrollPx.Y = (int)Math.Max(goal.Y - ScrollDistanceThreshold, Math.Min(m_scrollPx.Y, goal.Y + ScrollDistanceThreshold));
            }
        }
        #endregion

        /// <summary>
        /// Draws the map.
        /// </summary>
        /// <param name="batch"></param>
        public void Draw(GameTime time, SpriteBatch batch)
        {
            batch.Begin(SpriteSortMode.FrontToBack, BlendState.AlphaBlend);
            DrawBackground(time, batch);
            DrawLayer(batch, 0);
            DrawLayer(batch, 1);
            batch.End();
            DrawWater(time, batch);
            batch.Begin(SpriteSortMode.FrontToBack, BlendState.AlphaBlend);
            DrawLayer(batch, 2);
            DrawGameObjects(time, batch);
            DrawParticles(time, batch);
            HUD.Draw(time, batch);
            batch.End();
        }
        /// <summary>
        /// Draws the particles.
        /// </summary>
        /// <param name="time"></param>
        /// <param name="batch"></param>
        void DrawParticles(GameTime time, SpriteBatch batch)
        {
            GameObjects.Particles.ParticlePools.Update(time, batch, m_scrollPx);
            GameObjects.Shoots.ShootPools.Draw(time, batch, m_scrollPx);
        }
        /// <summary>
        /// Draws the Game Objects.
        /// </summary>
        void DrawGameObjects(GameTime time, SpriteBatch batch)
        {
            foreach (GameObjects.GameObject obj in m_gameObjects)
            {
                obj.Draw(time, batch, m_scrollPx);
            }
            m_player.Draw(time, batch, m_scrollPx);
        }
        /// <summary>
        /// Draws the water.
        /// </summary>
        void DrawWater(GameTime time, SpriteBatch batch)
        {

        }

        Texture2D m_backgroundTexture;
        /// <summary>
        /// Draws the background.
        /// </summary>
        void DrawBackground(GameTime time, SpriteBatch batch)
        {
            
            batch.Draw(m_backgroundTexture, new Rectangle(0, 0, Globals.ScreenWidth, Globals.ScreenHeight), null, Color.White, 0.0f, Vector2.Zero, SpriteEffects.None, DrawingDepths.PanoramaDepth);
        }
        /// <summary>
        /// Draws a map layer.
        /// </summary>
        void DrawLayer(SpriteBatch batch, int z)
        {
            // Draws the tiles
            int viewportX = (int)m_scrollPx.X / GameConstants.Tilesize;
            int viewportY = (int)m_scrollPx.Y / GameConstants.Tilesize;
            int viewportW = Globals.ScreenWidth / GameConstants.Tilesize + 1;
            viewportW = Math.Min(viewportW, m_tileIds[0].GetLength(0) - viewportX);
            int viewportH = Globals.ScreenHeight / GameConstants.Tilesize + 1;
            viewportH = Math.Min(viewportH, m_tileIds[0].GetLength(1) - viewportY);

            Rectangle rect = new Rectangle();
            Rectangle dstRect = new Rectangle();
            dstRect.Width = GameConstants.Tilesize;
            dstRect.Height = GameConstants.Tilesize;
            int id = 0;

            int startTileX = (int)(m_scrollPx.X / GameConstants.Tilesize);
            int startTileY = (int)(m_scrollPx.Y / GameConstants.Tilesize);
            int endTileX = startTileX + viewportW;
            int endTileY = startTileY + viewportH;
            
            for (int x = startTileX; x < endTileX; x++)
            {
                dstRect.X = (int)(x * GameConstants.Tilesize - m_scrollPx.X);
                for (int y = startTileY; y < endTileY; y++)
                {
                    dstRect.Y = (int)(y * GameConstants.Tilesize - m_scrollPx.Y);
                    id = m_tileIds[z][x, y];
                    if (id != -1)
                    {
                        TilesetWork.GetSrcRect(id, ref rect);
                        batch.Draw(m_tilesetTexture, dstRect, rect, Color.White, 0, Vector2.Zero, SpriteEffects.None, DrawingDepths.MapLayerDepths[z]);
                    }
                }
            }
        }
        /// <summary>
        /// Disposes the map it can't be used after that.
        /// </summary>
        public void Dispose()
        {
            m_gameObjects.Clear();
            m_player.Dispose();
            GameObjects.Particles.ParticlePools.Dispose();
        }

        #region Loading
        /// <summary>
        /// Resets the map before loading
        /// </summary>
        void ResetMap()
        {
            m_gameObjects.Clear();
            m_world.Clear();
            m_world.ClearForces();
        }
        /// <summary>
        /// Loads the player.
        /// </summary>
        void LoadPlayer()
        {
            m_player = new Player();
            ModuleSet set = new ModuleSet();
            GameObjectInit init = new GameObjectInit();
            set.Base.SimStartX = Globals.Cfg.PlayerStartPositionSim.X;
            set.Base.SimStartY = Globals.Cfg.PlayerStartPositionSim.Y;
            set.Base.Name = "LOLILOL";
            set.Base.Z = DrawingDepths.PlayerDepth;
            PhysicalObjectModule phi = new PhysicalObjectModule();
            phi.BodyType = BodyType.Dynamic;
            phi.ShapeSizeSim = new Vector2(0.32f, 0.32f);
            phi.BodyCategory = BodyCategories.Friend;
            phi.BodyDensity = 80f;
            phi.BodyFriction = 0.08f;
            phi.IsFixedRotation = false;
            phi.ShapeType = ShapeType.Capsule;
            GameEventModule ev = new GameEventModule();
            set["physical_object"] = phi;
            set["game_event"] = ev;
            ev.TextureName = "RunTimeAssets\\Graphics\\GameObjects\\test";
            ev.RegisterCollisions = true;
            init.ModuleSet = set;
            m_player.InitializingData = init;
            m_player.Initialize();
        }
        /// <summary>
        /// Loads a map.
        /// </summary>
        public void LoadMap(MapInitializingData data, int mapId)
        {
            ResetMap();
            LoadPlayer();
            m_sizeSim = data.SimSize;
            // Loads the MapDll.
            if (!Assemblies.ContainsKey(mapId))
            {
                string filename = Ressources.FileRessourceProvider.ContentDir +
                    "RunTimeAssets\\Data\\Maps\\Map" + mapId.ToString().PadLeft(4, '0') + ".uefmap.dll";

                if(System.IO.File.Exists(filename))
                    Assemblies.Add(mapId, Assembly.LoadFrom(filename));
            }
            // Loads game objects.
            foreach (GameObjectInit obj in data.GameObjects)
            {
                Type t = Assembly.GetExecutingAssembly().GetType(obj.Type);
                GameObject o = (GameObject)Activator.CreateInstance(t);
                o.MapId = mapId;
                o.InitializingData = obj;
                o.Initialize();
                
                m_gameObjects.Add(o);
            }

            // Load tileset.
            m_tileset = Ressources.FileRessourceProvider.LoadTileset(data.TilesetId);
            m_tilesetTexture = TilesetWork.GetTexture(m_tileset);
            m_tileIds = data.TileIds;
            m_backgroundTexture = Globals.Content.Load<Texture2D>("RunTimeAssets\\Graphics\\GameObjects\\mountains");

            // Load tile bodies
            m_TileBodies = GenerateMapBodies(data);
                
        }

        /// <summary>
        /// Generate the map's bodies.
        /// </summary>
        /// <returns></returns>
        static List<Body> GenerateMapBodies(MapInitializingData data)
        {
            List<Body> bodies = new List<Body>();

            foreach(Vertices vertices in data.Polygons)
            {
                Body body = new Body(Globals.World);
                FixtureFactory.AttachPolygon(vertices, 0.5f, body);
                body.BodyType = BodyType.Static;
                body.UserData = BodyCategories.Wall;
                body.AngularDamping = 0.5f;
            }

            return bodies;
        }
        /// <summary>
        /// Loads a map given its id
        /// </summary>
        /// <param name="id"></param>
        public void LoadMap(int id)
        {
            MapInitializingData map = Ressources.ContentRessourceProvider.LoadMap(id);
            LoadMap(map, id);
        }

        /* ---------------------------------------------------------------
         * Utils
         * -------------------------------------------------------------*/
        #region Utils
        protected float sim(double v) { return ConvertUnits.ToSimUnits(v); }
        protected Vector2 sim(Vector2 v) { return ConvertUnits.ToSimUnits(v); }
        protected float disp(float v) { return ConvertUnits.ToDisplayUnits(v); }
        protected Vector2 disp(Vector2 v) { return ConvertUnits.ToDisplayUnits(v); }
        #endregion
        #endregion
        #endregion
        /* --------------------------------------------------------------------------------
        * API
        * -------------------------------------------------------------------------------*/
        /// <summary>
        /// Returns the first object of the map with the given name.
        /// Returns null if it doesn't exists.
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public GameEvent GetEventByName(string name)
        {
            foreach (GameObject obj in m_gameObjects)
            {
                if (obj.Modules.Base.Name == name && obj is GameEvent)
                    return (GameEvent)obj;
            }
            return null;
        }
        /// <summary>
        /// Returns the unique object with the given id in the map.
        /// Returns null if it doesn't exist.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public GameEvent GetEventById(int id)
        {
            foreach (GameObject obj in m_gameObjects)
            {
                if (obj.Modules.Base.BehaviorID == id && obj is GameEvent)
                    return (GameEvent)obj;
            }
            return null;
        }
        
        /// <summary>
        /// Returns the first object of the map with the given name.
        /// Returns null if it doesn't exists.
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public GameObject GetObjectByName(string name)
        {
            foreach (GameObject obj in m_gameObjects)
            {
                if (obj.Modules.Base.Name == name)
                    return obj;
            }
            return null;
        }
        /// <summary>
        /// Returns the unique object with the given id in the map.
        /// Returns null if it doesn't exist.
        /// </summary>
        /// <param name="id"></param>
        /// <returns></returns>
        public GameObject GetObjectById(int id)
        {
            foreach (GameObject obj in m_gameObjects)
            {
                if (obj.Modules.Base.BehaviorID == id)
                    return obj;
            }
            return null;
        }
    }
}
